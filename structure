TODO:
  [ ] Repetition typing for syntax types
  [ ] Macros (procedural!)
  [ ] Traits
  [ ] Fancy bindings
  [ ] Modules
  [ ] Kinds?
  [ ] Switchable tokenizer
  [ ] Worry about parse error messages


Like a normal language implementation, we have
 a reader that turns text into tokens,
 a parser that turns tokens into AST,
 a typechecker that validates an AST,
 a macro expander that transforms
  an AST with user-defined forms
  into an AST in a core language,
 and an evaluator that turns ASTs into behavior.
Unlike a normal language implementation,
 the typechecker runs before the macro expander.
This means that the typechecker has to operate on
 user-defined AST nodes,
  which is possible,
   because (I think) one can derive a typechecker for a form
    from the type of its definition.
The weirdness of this language implementation starts with the AST.

Well, the parser and tokenizer are weird, but they don't have to be.



Language definition:

[Ast] ast.rs and ast_walk.rs

The core language is small, but the AST definition is much smaller.
It contains only:
 * variable introductions and references,
 * binding information,
 * (temporary parsing information),
 * quotation level indicators, and
 * `Node`, which represents complex AST nodes.

 `walk` traverses these nodes and keeps the environment
  (actually a stack of environments, for nested quotation)
  set up appropriately.

A "positive" walk takes an environment of `Elt`, and results in a single `Elt`.
A "negative" walk takes an `Elt`, and produces an environment of `Elt`.
Evaluation or typechecking expressions is a positive walk;
 evaluating or typechecking patterns is negative.


[Core] core_forms.rs, core_type_forms.rs, core_qq_forms.rs, core_macro_forms.rs

The Turing-complete "core" language is Unseemly's user interface.

There are separate files
 for defining the types themselves ("core_type_forms.rs")
 and for defining syntax (un)quotation ("core_qq_forms.rs").


Pipeline:
                             ⋮              ⋮           ⋮
                      →  [TypeSynth]  →  [Expand] →  [Evaluate] ↩ (phase 2)
                      →  [TypeSynth]  →  [Expand] →  [Evaluate] ↩ (phase 1)
  [Read]  →  [Parse]  →  [TypeSynth]  →  [Expand] →  [Evaluate] (runtime)
          ↑           ↑               ↑           ↑
      TokenTree      Ast           Ast:Ty      Ast:Ty (core)


[Read] read.rs
  The reader is very simple.
  Tokens boundaries are whitespace and the inside boundaries of ()[]{}.
  If a token ends with ([{,
   it should match a token that is identical
    except for starting with )]} instead.

[Parse] parse.rs and earley.rs
  The parser has to parse arbitrary grammars (`FormPat`s).
  Furthermore, it must be able to
   extend the grammar it is currently parsing
    (it does this by extending `SynEnv`),
   and generate new `Form`s.
  Extending the grammar may entail invoking the rest of the pipeline
   (Typesynth and Evaluate),
   the timing of which should be controlled by phasing.

[TypeSynth] ty.rs
  Type synthesis.

  It should be possible to derive type synthesis for macros!
  Synthesize a type for the macro body, and it'll tell you what you get.
  I think.
  If not, there's not much point to making this language.

[Evaluate] eval.rs
  Evaluation is a tree traversal, surprisingly similar to type synthesis.

  Maybe at some point, this will be translation into some other language
    (like Ocaml? Rust? LLVM?),
   but it may be faster to interpret
    the many small programs that macros are.

[↩ (Reflection)] reify.rs
  Macros are programs that manipulate `Ast`s
   (they can also access environments).
  We need to reflect internal `Ast`s into Unseemly values
   and reify them back out.

  Fun fact: `Ast` transitively includes
   almost every type in the compiler.
  So we use a macro (see reification_macros.rs)
    to generate the reification/reflection,
   rather than do it by hand.



Important data structures:

  `Name` name.rs
    Will contain hygiene metadata, eventually

  `TokenTree` read.rs
    The result of reading; a tree with nodes at every ()[]{}

  `FormPat` parse.rs
    Grammar for forms (core and user-defined)

  `Form` form.rs
    Everything one needs to know about a language form. Contains:
     * `grammar : FormPat` [Parse] -- grammar (how we know the user used the form)
       Also contains:
       * how things should bind
       * grammar "binding" information (syntax extension)
     * `synth_type : WalkRule` [TypeSynth] -- typechecking rule
     * `eval : WalkRule` [Evaluate] -- evaluation rule
     * `quasiquote : WalkRule` [Evaluate] -- trivial, except for unquotation
     * TODO [misc] -- pretty-printing guidance

  `Ast` ast.rs
    Syntax, in its logical structure.

  `Beta` beta.rs
    How terms bind. Surprisingly important!

  `SynEnv` parse.rs
    Indicates what the grammar is at a particular point.
    [Map from [named grammar nodes] to `FormPat`]

  `EnvMBE` util/mbe.rs
    Ergonomic (...in a sense) representation for the contents of `Ast` nodes
     which have parts that can repeat `n` times.

  Other imporant things:

  alpha.rs has α-equivalence utilities, used by `ast_walk.rs`



Questions:

What if a macro like Rust's `try!`
 has a type error in its return value?
What happens? What should happen?
